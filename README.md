# Docker образ для gcc-arm проектов

Базовый образ: `Ubuntu 24.04`

Предустановленые пакеты:

* build-essential
* wget
* sudo
* cmake
* git
* ninja-build

Тулчейн: `gcc-arm-none-eabi-10.3-2021.10-x86_64-linux` с официального [сайта ](https://developer.arm.com/). По умолчанию распакован в `/opt/gcc-arm-none-eabi`.

Основной пользователь: `ubuntu` с доступом к `sudo` и группе `plugdev`.

Создание образа:

```bash
$ docker build -t image-docker-gcc-arm
```

> __ВАЖНО!__ При сборке образа под Windows может возникнуть проблема с разрешением DNS имён при загрузке тулчейна через `wget`. Для решения проблемы в конфигурации демона `Docker` требуется добавить:

```
"dns": [
    "8.8.8.8"
]
```

## Описание

В образе реализована система для сборки проектов для ARM микроконтроллеров с использованием тулчейна `gcc-arm-none-eabi`. Подходит для компиляции артефактов CubeMX-based проектов, сгенерированных для системы сборки `Makefile` или других проектов в т.ч. с системой сборки `CMake`.

> __ВАЖНО!__ При изменении конфигурации проекта через `.ioc` файл в генераторе `CubeMX` всегда проверять изменения в `Makefile`, т.к. он тоже перезагружается.

## Использование

Проекты собираются из контейнера через командную строку, в `VS Code` через плагин `Dev Containers` (требуется установка `Docker desktop`) или в среде `CubeIDE`.

Для проектов, создаваемых в `CubeMX` требуется следующая подготовка перед генерацией:

<p align="center">
    <img src="docs/cubemx_steps.png" width=800>
</p>

На шаге `5` допускается выбор копирования всех или только необходимых библиотек HAL внутрь проекта (зависит от реализации целевого проекта).

### Сборка из командной строки

Создание контейнера из образа с монтированием текущей рабочей директории (это директория целевого проекта):

```bash
$ docker container create -v ./source_dir:/home/dest_dir -w /home/dest_dir -i -t --name my_container_name image-docker-gcc-arm
```

Запуск и подключение к контейнеру в интерактивном режиме:

```bash
$ docker container start --attach -i my_container_name
```

Сборка:

```bash
$ make clean
$ make all
```

Допускается передача параметров внутрь сборки через ключ `-e` для экспорта переменных среды, например:

```bash
make all -j8 -e OPT=-O3 DEBUG=0
```

### Сборка в VS Code

Базовая структура директорий для проекта в `VS Code` приведена в `./vscode`.

Для работы должен быть установлен плагин `Dev Containers`. Конфигурация в `.devcontainer/devcontainer.json`.

При открытии проекта выбрать `Reopen in Container`.

![reopen_in_container.png](docs/reopen-in-container.png)

После первого открытия в контейнере выполнить `Dry-run` конфигурацию плагина `Makefile tools` для индексации целевого проекта.

Сборка доступна из терминала контейнера:

```bash
$ make clean
$ make all
```

Или с использованием тасков через плагин `Task Explorer`:

![reopen_in_container.png](docs/vscode_tasks.png)

Нативные таски (отмечены красным символом в дереве с именем `make`) отображают все цели проанализированного `Makefile` проекта. Они работают т.к. для `make` выполнено переопределение имени бинарного файла (вместо `nmake`) в `devcontainer.json`:

```json
"taskExplorer.pathToPrograms": {
    "make": "make"
}
```

Для шаблонного примера заведены задачи `vscode` для сборки и программирования, а также выполнены настройки для работы плагина отладки, автодополнений и запуска отладчика `OpenOCD`. Для корректной работы отладчика необходимо сконфигурировать `.vscode/launch.json` под используемый микроконтроллер, а также не забыть предоставить `SVD-файл` (должен находится в директории `tools`).

### Доступ к программатору

Для возможности работы с USB-программаторами (ST-Link) из контейнера на хосте под управлением Linux совместимой ОС требуется настроить права устройств через `udev`:

* Скопировать из директории `st-link-udev-rules` все файлы в `/etc/udev/rules.d/` на хосте (требуются права администратора),
* Перезагрузить ПК или выполнить:

```bash
# udevadm control --reload-rules && udevadm trigger
```

### Сборка в CubeIDE

В среду `CubeIDE` проект импортируется, как `Makefile`-проект.

<p align="center">
    <img src="docs/cubeide_import_1.png" width=300>
    <img src="docs/cubeide_import_2.png" width=400>
    <img src="docs/cubeide_import_3.png" width=400>
</p>

Для выполнения отладки необходимо дополнительно сконфигурировать среду, указав целевой микроконтроллер в свойствах проекта.

<p align="center">
    <img src="docs/cubeide_settings_mcu.png" width=600>
</p>


### CI

В проекте присутствует скрипт-шаблон для сборки Docker-образа в GitLab CI.

### Трассировка через SWO

Реализована конфигурация для запучка отладчика с трассировкой через SWO. Перед использованием требуется скорректировать в `launch.json` частоты CPU и работы порта SWO.

В программе для контроллера требуется переопределить реализацию функции `__io_putchar` (для arm-gcc):

```c
int __io_putchar(int ch)
{
 // Write character to ITM ch.0
 ITM_SendChar(ch);
 return(ch);
}
```

Затем в месте использования трассировщика:

```c
#include <stdio.h>

...
printf("Hello from SWO!\n");
...
```

Возможны ошибки компилятора или линковщика, связанные с отсутсвием реализаций системных вызовов. Проверить команду запуска компилятора (должен быть ключ `--specs=nano.specs `) и линковщика (должен быть ключ `--specs=nosys.specs`).